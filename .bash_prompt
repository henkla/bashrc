# custom prompt
function __setprompt
{
	local LAST_COMMAND=$? # Must come first!

	# Define colors
    local BGBLACK="\033[48;5;234m"
    local BGLIGHTGRAY="\033[48;5;236m"
	local WHITE="\033[1;37m"
	local DARKGRAY="\033[1;30m"
	local RED="\033[0;31m"
	local LIGHTRED="\033[1;31m"
	local GREEN="\033[0;32m"
	local LIGHTGREEN="\033[1;32m"
	local BROWN="\033[0;33m"
	local YELLOW="\033[1;33m"
	local BLUE="\033[1;34m"
	local LIGHTBLUE="\033[1;34m"
	local MAGENTA="\033[0;35m"
	local LIGHTMAGENTA="\033[1;35m"
	local CYAN="\033[0;36m"
	local LIGHTCYAN="\033[1;36m"
	local NOCOLOR="\033[0m"
	local INVERT="\e[7m"

	# Show error exit code if there is one
	if [[ $LAST_COMMAND != 0 ]]; then

		# PS1="\[${RED}\](\[${LIGHTRED}\]ERROR\[${RED}\])-(\[${LIGHTRED}\]Exit Code \[${WHITE}\]${LAST_COMMAND}\[${RED}\])-(\[${LIGHTRED}\]"
		PS1="\[${DARKGRAY}\](\[${LIGHTRED}\]ERROR\[${DARKGRAY}\])-(\[${RED}\]Exit Code \[${LIGHTRED}\]${LAST_COMMAND}\[${DARKGRAY}\])-(\[${RED}\]"
		if [[ $LAST_COMMAND == 1 ]]; then
			PS1+="General error"
		elif [ $LAST_COMMAND == 2 ]; then
			PS1+="Missing keyword, command, or permission problem"
		elif [ $LAST_COMMAND == 126 ]; then
			PS1+="Permission problem or command is not an executable"
		elif [ $LAST_COMMAND == 127 ]; then
			PS1+="Command not found"
		elif [ $LAST_COMMAND == 128 ]; then
			PS1+="Invalid argument to exit"
		elif [ $LAST_COMMAND == 129 ]; then
			PS1+="Fatal error signal 1"
		elif [ $LAST_COMMAND == 130 ]; then
			PS1+="Script terminated by Control-C"
		elif [ $LAST_COMMAND == 131 ]; then
			PS1+="Fatal error signal 3"
		elif [ $LAST_COMMAND == 132 ]; then
			PS1+="Fatal error signal 4"
		elif [ $LAST_COMMAND == 133 ]; then
			PS1+="Fatal error signal 5"
		elif [ $LAST_COMMAND == 134 ]; then
			PS1+="Fatal error signal 6"
		elif [ $LAST_COMMAND == 135 ]; then
			PS1+="Fatal error signal 7"
		elif [ $LAST_COMMAND == 136 ]; then
			PS1+="Fatal error signal 8"
		elif [ $LAST_COMMAND == 137 ]; then
			PS1+="Fatal error signal 9"
		elif [ $LAST_COMMAND -gt 255 ]; then
			PS1+="Exit status out of range"
		else
			PS1+="Unknown error code"
		fi
		PS1+="\[${DARKGRAY}\])\[${NOCOLOR}\]\n"
	else
		PS1=""
	fi


	if [[ $EUID -ne 0 ]]; then
		PS1+="\[${NOCOLOR}\]\e[1m\e[5m» \[${NOCOLOR}\]" # Normal user
	else
		PS1+="\[${RED}\]>>>\[${NOCOLOR}\] " # Root user

	fi

	######################################################################
	PS1="\[${BLUE}\]\$(parse_git_branch)\$(parse_current_dir) # \[${NOCOLOR}\]"
	######################################################################

	# PS2 is used to continue a command using the \ character
	PS2="\[\e[1;91m\]\[${DARKGRAY}\]>>>\[${NOCOLOR}\] "

	# PS3 is used to enter a number choice in a script
	PS3='Please enter a number from above list: '

	# PS4 is used for tracing a script in debug mode
	PS4='\[${DARKGRAY}\]+\[${NOCOLOR}\] '
}

function parse_current_dir() 
{
	dir=/home/
	depth=$(pwd | grep -o "/" | wc -l)
	let field="($depth+1)"

	if (( $depth < 3 )); then

		if [[ $(pwd) == "/home/$(whoami)" ]]; then

			printf "~"
			exit 0

		else

			printf "$(pwd)"
			exit 0

		fi

	elif (( $depth > 2 )); then

		if [[ $(pwd | cut -d "/" -f3) == $(whoami) ]]; then
			if [[ $(pwd | cut -d "/" -f2) == "home" ]]; then

				if (( $depth == 3 )); then
        	                	dir_right=$(pwd | cut -d "/" -f$field)
               		         	printf "~/$dir_right"
					exit 0

				else

					dir_right=$(pwd | cut -d "/" -f$field)
                               		 printf "~/../$dir_right"                                                                                                          
                               	 	exit 0
				fi
			fi
		else

			dir_left=$(pwd | cut -d "/" -f2)
			dir_right=$(pwd | cut -d "/" -f$field)
			printf "/$dir_left/../$dir_right"
			exit 0
		fi
	fi

	exit 1
}

parse_git_branch() {
    git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/' | sed 's/$/ » /'
}
